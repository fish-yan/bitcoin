"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMPCSignedMessage = exports.verify = exports.sign = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const txBuild_1 = require("./txBuild");
const MAGIC_BYTES = Buffer.from('Bitcoin Signed Message:\n');
function varintBufNum(n) {
    let buf;
    if (n < 253) {
        buf = Buffer.alloc(1);
        buf.writeUInt8(n, 0);
    }
    else if (n < 0x10000) {
        buf = Buffer.alloc(1 + 2);
        buf.writeUInt8(253, 0);
        buf.writeUInt16LE(n, 1);
    }
    else if (n < 0x100000000) {
        buf = Buffer.alloc(1 + 4);
        buf.writeUInt8(254, 0);
        buf.writeUInt32LE(n, 1);
    }
    else {
        buf = Buffer.alloc(1 + 8);
        buf.writeUInt8(255, 0);
        buf.writeInt32LE(n & -1, 1);
        buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
    }
    return buf;
}
function magicHash(message) {
    const prefix1 = varintBufNum(MAGIC_BYTES.length);
    const messageBuffer = Buffer.from(message);
    const prefix2 = varintBufNum(messageBuffer.length);
    const buf = Buffer.concat([prefix1, MAGIC_BYTES, prefix2, messageBuffer]);
    return crypto_lib_1.base.doubleSha256(buf);
}
function toCompact(i, signature, compressed) {
    if (!(i === 0 || i === 1 || i === 2 || i === 3)) {
        throw new Error('i must be equal to 0, 1, 2, or 3');
    }
    let val = i + 27 + 4;
    if (!compressed) {
        val = val - 4;
    }
    return Buffer.concat([Uint8Array.of(val), Uint8Array.from(signature)]);
}
;
function sign(wifPrivate, message, network) {
    const hash = magicHash(message);
    if (!wifPrivate) {
        return crypto_lib_1.base.toHex(hash);
    }
    const privateKey = crypto_lib_1.base.fromHex((0, txBuild_1.privateKeyFromWIF)(wifPrivate, network));
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(hash), privateKey);
    return crypto_lib_1.base.toBase64(toCompact(recovery, signature, true));
}
exports.sign = sign;
function verify(publicKey, message, sig) {
    const hash = magicHash(message);
    const sigBytes = crypto_lib_1.base.fromBase64(sig);
    const v = sigBytes[0] - 27 - 4;
    const rs = sigBytes.slice(1);
    return crypto_lib_1.signUtil.secp256k1.verify(Buffer.from(hash), rs, v, crypto_lib_1.base.fromHex(publicKey));
}
exports.verify = verify;
function getMPCSignedMessage(hash, sig, publicKey) {
    const signature = crypto_lib_1.base.fromHex(sig);
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    const recovery = crypto_lib_1.signUtil.secp256k1.getV(crypto_lib_1.base.fromHex(hash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey));
    return crypto_lib_1.base.toBase64(toCompact(recovery, signature, true));
}
exports.getMPCSignedMessage = getMPCSignedMessage;
//# sourceMappingURL=message.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseWallet = exports.secp256k1SignTest = void 0;
const error_1 = require("./error");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
function secp256k1SignTest(privateKey) {
    const msgHash = crypto_lib_1.base.sha256("secp256k1-test");
    const publicKey = crypto_lib_1.signUtil.secp256k1.publicKeyCreate(privateKey, false);
    const { signature, recovery } = crypto_lib_1.signUtil.secp256k1.sign(Buffer.from(msgHash), privateKey);
    return crypto_lib_1.signUtil.secp256k1.verify(msgHash, signature, recovery, publicKey);
}
exports.secp256k1SignTest = secp256k1SignTest;
class BaseWallet {
    getRandomPrivateKey() {
        try {
            while (true) {
                const privateKey = crypto_lib_1.base.randomBytes(32);
                if (secp256k1SignTest(privateKey)) {
                    return Promise.resolve(crypto_lib_1.base.toHex(privateKey, true));
                }
            }
        }
        catch (e) {
        }
        return Promise.reject(error_1.GenPrivateKeyError);
    }
    getDerivedPrivateKey(param) {
        return crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic)
            .then((masterSeed) => {
            let childKey = crypto_lib_1.bip32.fromSeed(masterSeed).derivePath(param.hdPath);
            if (childKey.privateKey) {
                let privateKey = crypto_lib_1.base.toHex(childKey.privateKey);
                return Promise.resolve("0x" + privateKey);
            }
            else {
                return Promise.reject(error_1.GenPrivateKeyError);
            }
        }).catch((e) => {
            return Promise.reject(error_1.GenPrivateKeyError);
        });
    }
    getDerivedPath(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    validPrivateKey(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    signMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    verifyMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    ecRecover(message, signature) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getAddressByPublicKey(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCRawTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCRawMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getMPCSignedMessage(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getHardWareRawTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getHardWareSignedTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getHardWareMessageHash(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    calcTxHash(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    getRawTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    validSignedTransaction(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
    estimateFee(param) {
        return Promise.reject(error_1.NotImplementedError);
    }
}
exports.BaseWallet = BaseWallet;
//# sourceMappingURL=wallet.js.map
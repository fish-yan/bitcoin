/// <reference types="node" />
import { DerivePriKeyParams, GetDerivedPathParam, NewAddressParams, SignTxParams, TypedMessage, ValidAddressParams, ValidPrivateKeyParams, VerifyMessageParams, GetAddressParams, MpcRawTransactionParam, MpcTransactionParam, HardwareRawTransactionParam, CalcTxHashParams, GetRawTransactionParams, ValidSignedTransactionParams, MpcMessageParam } from './common';
export declare function secp256k1SignTest(privateKey: Buffer): boolean;
declare abstract class BaseWallet {
    getRandomPrivateKey(): Promise<any>;
    getDerivedPrivateKey(param: DerivePriKeyParams): Promise<any>;
    abstract getNewAddress(param: NewAddressParams): Promise<any>;
    abstract validAddress(param: ValidAddressParams): Promise<any>;
    abstract signTransaction(param: SignTxParams): Promise<any>;
    getDerivedPath(param: GetDerivedPathParam): Promise<any>;
    validPrivateKey(param: ValidPrivateKeyParams): Promise<any>;
    signMessage(param: SignTxParams): Promise<string>;
    verifyMessage(param: VerifyMessageParams): Promise<boolean>;
    ecRecover(message: TypedMessage, signature: string): Promise<string>;
    getAddressByPublicKey(param: GetAddressParams): Promise<any>;
    getMPCRawTransaction(param: MpcRawTransactionParam): Promise<any>;
    getMPCTransaction(param: MpcTransactionParam): Promise<any>;
    getMPCRawMessage(param: MpcRawTransactionParam): Promise<any>;
    getMPCSignedMessage(param: MpcMessageParam): Promise<any>;
    getHardWareRawTransaction(param: SignTxParams): Promise<any>;
    getHardWareSignedTransaction(param: HardwareRawTransactionParam): Promise<any>;
    getHardWareMessageHash(param: SignTxParams): Promise<any>;
    calcTxHash(param: CalcTxHashParams): Promise<string>;
    getRawTransaction(param: GetRawTransactionParams): Promise<string>;
    validSignedTransaction(param: ValidSignedTransactionParams): Promise<any>;
    estimateFee(param: SignTxParams): Promise<number>;
}
export { BaseWallet };

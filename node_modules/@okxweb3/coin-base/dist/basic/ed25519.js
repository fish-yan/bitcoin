"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ed25519_getDerivedPrivateKey = exports.isValidPath = exports.ed25519_getRandomPrivateKey = exports.ed25519SignTest = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
function ed25519SignTest(privateKey) {
    const msgHash = crypto_lib_1.base.sha256("ed25519-test");
    const publicKey = crypto_lib_1.signUtil.ed25519.publicKeyCreate(privateKey);
    const signature = crypto_lib_1.signUtil.ed25519.sign(msgHash, privateKey);
    return crypto_lib_1.signUtil.ed25519.verify(msgHash, signature, publicKey);
}
exports.ed25519SignTest = ed25519SignTest;
function ed25519_getRandomPrivateKey(concatPub, encode) {
    while (true) {
        const randBytes = crypto_lib_1.base.randomBytes(32);
        if (crypto_lib_1.signUtil.ed25519.privateKeyVerify(randBytes)) {
            if (ed25519SignTest(randBytes)) {
                const publicKey = crypto_lib_1.signUtil.ed25519.publicKeyCreate(randBytes);
                const privateKey = concatPub ? crypto_lib_1.base.concatBytes(randBytes, publicKey) : randBytes;
                return encode === "base58" ? crypto_lib_1.base.toBase58(privateKey) : crypto_lib_1.base.toHex(privateKey);
            }
        }
    }
}
exports.ed25519_getRandomPrivateKey = ed25519_getRandomPrivateKey;
const pathRegex = new RegExp("^m(\\/[0-9]+')+$");
const replaceDerive = (val) => val.replace("'", '');
const HARDENED_OFFSET = 0x80000000;
function getMasterKeyFromSeed(seed) {
    const I = crypto_lib_1.base.hmacSHA512("ed25519 seed", seed);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return {
        key: IL,
        chainCode: IR,
    };
}
function CKDPriv({ key, chainCode }, index) {
    const indexBuffer = Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(index, 0);
    const data = Buffer.concat([Buffer.alloc(1, 0), key, indexBuffer]);
    const I = crypto_lib_1.base.hmacSHA512(chainCode, data);
    const IL = I.slice(0, 32);
    const IR = I.slice(32);
    return {
        key: IL,
        chainCode: IR,
    };
}
const isValidPath = (path) => {
    if (!pathRegex.test(path)) {
        return false;
    }
    return !path
        .split('/')
        .slice(1)
        .map(replaceDerive)
        .some(isNaN);
};
exports.isValidPath = isValidPath;
function derivePath(path, seed, offset = HARDENED_OFFSET) {
    if (!(0, exports.isValidPath)(path)) {
        throw new Error('Invalid derivation path');
    }
    const { key, chainCode } = getMasterKeyFromSeed(seed);
    const segments = path
        .split('/')
        .slice(1)
        .map(replaceDerive)
        .map(el => parseInt(el, 10));
    return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });
}
async function ed25519_getDerivedPrivateKey(param, concatPub, encode) {
    const seed = await crypto_lib_1.bip39.mnemonicToSeed(param.mnemonic);
    const derivedSeed = derivePath(param.hdPath, seed).key;
    const publicKey = crypto_lib_1.signUtil.ed25519.publicKeyCreate(derivedSeed);
    const privateKey = concatPub ? crypto_lib_1.base.concatBytes(derivedSeed, publicKey) : derivedSeed;
    return encode === 'base58' ? Promise.resolve(crypto_lib_1.base.toBase58(privateKey)) : Promise.resolve(crypto_lib_1.base.toHex(privateKey));
}
exports.ed25519_getDerivedPrivateKey = ed25519_getDerivedPrivateKey;
//# sourceMappingURL=ed25519.js.map